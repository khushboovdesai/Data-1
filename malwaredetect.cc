/*
 * counter.{cc,hh} -- element counts packets, measures packet rate
 * Eddie Kohler
 *
 * Copyright (c) 1999-2000 Massachusetts Institute of Technology
 * Copyright (c) 2008 Regents of the University of California
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, subject to the conditions
 * listed in the Click LICENSE file. These conditions include: you must
 * preserve this copyright notice, and you cannot mention the copyright
 * holders in advertising related to the Software without their permission.
 * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
 * notice is a summary of the Click LICENSE file; the license in that file is
 * legally binding.
 */

#include <click/config.h>
#include "malwaredetect.hh"
#include <click/error.hh>
#include <click/confparse.hh>
#include <click/args.hh>
#include <click/handlercall.hh>
#define SIZE 31
const int MAXS = 500;
const int MAXC = 26;
int out[MAXS];
int f[MAXS];
int g[MAXS][MAXC];
CLICK_DECLS


struct Queue
{
	int front, rear, size;
	unsigned capacity;
	int* array;
};

struct Queue* createQueue(unsigned capacity)
{
	struct Queue* queue = (struct Queue*) malloc(sizeof(struct Queue));
	queue->capacity = capacity;
	queue->front = queue->size = 0;
	queue->rear = capacity - 1;  // This is important, see the enqueue
	queue->array = (int*) malloc(queue->capacity * sizeof(int));
	return queue;
}


int isFull(struct Queue* queue)
{  return (queue->size == queue->capacity);  }

int isEmpty(struct Queue* queue)
{  return (queue->size == 0); }

void enqueue(struct Queue* queue, int item)
{
	if (isFull(queue))
		return;

	queue->rear = (queue->rear + 1)%queue->capacity;
	queue->array[queue->rear] = item;
	queue->size = queue->size + 1;
}

int dequeue(struct Queue* queue)
{
	if (isEmpty(queue))
		return INT_MIN;

	int item = queue->array[queue->front];
	queue->front = (queue->front + 1)%queue->capacity;
	queue->size = queue->size - 1;
	return item;
}


int front(struct Queue* queue)
{
	if (isEmpty(queue))
		return INT_MIN;
	return queue->array[queue->front];
}


int rear(struct Queue* queue)
{
	if (isEmpty(queue))
		return INT_MIN;
	return queue->array[queue->rear];
}







MalwareDetect::MalwareDetect()
  : _count_trigger_h(0), _byte_trigger_h(0)
{
}

MalwareDetect::~MalwareDetect()
{
  delete _count_trigger_h;
  delete _byte_trigger_h;
}

void
MalwareDetect::reset()
{
  _count = _byte_count = 0;
  _count_triggered = _byte_triggered = false;
}

int
MalwareDetect::configure(Vector<String> &conf, ErrorHandler *errh)
{
  String count_call, byte_count_call;
  if (Args(conf, this, errh)
      .read("COUNT_CALL", AnyArg(), count_call)
      .read("BYTE_COUNT_CALL", AnyArg(), byte_count_call).complete() < 0)
    return -1;

  if (count_call) {
    IntArg ia;
    if (!ia.parse_saturating(cp_shift_spacevec(count_call), _count_trigger))
      return errh->error("COUNT_CALL type mismatch");
    else if (ia.status == IntArg::status_range)
      errh->error("COUNT_CALL overflow, max %s", String(_count_trigger).c_str());
    _count_trigger_h = new HandlerCall(count_call);
  } else
    _count_trigger = (counter_t)(-1);

  if (byte_count_call) {
    IntArg ia;
    if (!ia.parse_saturating(cp_shift_spacevec(byte_count_call), _byte_trigger))
      return errh->error("BYTE_COUNT_CALL type mismatch");
    else if (ia.status == IntArg::status_range)
      errh->error("BYTE_COUNT_CALL overflow, max %s", String(_count_trigger).c_str());
    _byte_trigger_h = new HandlerCall(byte_count_call);
  } else
    _byte_trigger = (counter_t)(-1);

  return 0;
}

int
MalwareDetect::initialize(ErrorHandler *errh)
{
  if (_count_trigger_h && _count_trigger_h->initialize_write(this, errh) < 0)
    return -1;
  if (_byte_trigger_h && _byte_trigger_h->initialize_write(this, errh) < 0)
    return -1;
  reset();
  return 0;
}

int buildMatchingMachine(char arr[][SIZE], int k)
{
	memset(out, 0, sizeof out);
	memset(g, -1, sizeof g);

	int states = 1;
	for (int i = 0; i < k; ++i)
	{
		char word[5];
		strcpy(word, arr[i]);
		int wordleni = strlen(word);
		int currentState = 0;
		
		for (int j = 0; j < wordleni; ++j)
		{
			int ch = word[j] - 'a';
			if (g[currentState][ch] == -1)
				g[currentState][ch] = states++;

			currentState = g[currentState][ch];
		}
		out[currentState] |= (1 << i);
	}	
	for (int ch = 0; ch < MAXC; ++ch)
		if (g[0][ch] == -1)
			g[0][ch] = 0;

	memset(f, -1, sizeof f);
	//queue<int> q;
	struct Queue* q = createQueue(1000);
	
	for (int ch = 0; ch < MAXC; ++ch)
	{
		if (g[0][ch] != 0)
		{
			f[g[0][ch]] = 0;
			//q.push(g[0][ch]);
			enqueue(q, g[0][ch]);
		}
	}
	
	while (q->size)
	{	
		//int state = q.front();
		int state = front(q);
		
		//q.pop();
		dequeue(q);
		
		for (int ch = 0; ch <= MAXC; ++ch)
		{
			if (g[state][ch] != -1)
			{
				int failure = f[state];
				while (g[failure][ch] == -1)
					failure = f[failure];

				failure = g[failure][ch];
				f[g[state][ch]] = failure;

				out[g[state][ch]] |= out[failure];
				//q.push(g[state][ch]);
				enqueue(q, g[state][ch]);
			}
		}
	}
	return states;
}


int findNextState(int currentState, char nextInput)
{
	int answer = currentState;
	int ch = nextInput - 'a';

	while (g[answer][ch] == -1)
		answer = f[answer];

	return g[answer][ch];
}

void searchWords(char arr[][SIZE], int k, char text[])
{
	buildMatchingMachine(arr, k);
	int currentState = 0;
	
	for (int i = 0; i < strlen(text); ++i)
	{
		currentState = findNextState(currentState, text[i]);
		if (out[currentState] == 0)
			continue;

		for (int j = 0; j < k; ++j)
		{
			if (out[currentState] & (1 << j))
			{
				//cout << "Word " << arr[j] << " appears from "<< i - strlen(arr[j]) + 1 << " to " << i << endl;
				int lenkv = i - strlen(arr[j]) + 1 ;
				printf("Word %s appears from %d to %d \n", arr[j], lenkv ,i);
			}
		}
	}
}



Packet *
MalwareDetect::simple_action(Packet *p)
{
    _count++;
     if(_count<=50) {
	printf("Count value from the cc file is %d\n",_count);
     }
     else {
	printf("Count value exceeded threshold \n");
     }

     char arr[3][31] = {"mal", "ware", "nik"};
     char text[30] = "abcmalwarexxsigndoniknik";
     searchWords(arr, 3, text);
     

    _byte_count += p->length();
    _rate.update(1);
    _byte_rate.update(p->length());

  if (_count == _count_trigger && !_count_triggered) {
    _count_triggered = true;
    //cout<<"count triggered\n";
    if (_count_trigger_h){
      (void) _count_trigger_h->call_write();
       //cout<<"count triggered header\n";
  }
}
  if (_byte_count >= _byte_trigger && !_byte_triggered) {
    _byte_triggered = true;
     //cout<<"byte triggered";
    if (_byte_trigger_h){
      (void) _byte_trigger_h->call_write();
      //cout<<"byte triggered header\n";
  }
}

  return p;
}


enum { H_COUNT, H_BYTE_COUNT, H_RATE, H_BIT_RATE, H_BYTE_RATE, H_RESET,
       H_COUNT_CALL, H_BYTE_COUNT_CALL };

String
MalwareDetect::read_handler(Element *e, void *thunk)
{
    MalwareDetect *c = (MalwareDetect *)e;
    switch ((intptr_t)thunk) {
      case H_COUNT:
        //cout<<"We are here\n";
	return String(c->_count);
      case H_BYTE_COUNT:
	return String(c->_byte_count);
      case H_RATE:
	c->_rate.update(0);	// drop rate after idle period
	return c->_rate.unparse_rate();
      case H_BIT_RATE:
	c->_byte_rate.update(0); // drop rate after idle period
	// avoid integer overflow by adjusting scale factor instead of
	// multiplying
	if (c->_byte_rate.scale() >= 3)
	    return cp_unparse_real2(c->_byte_rate.scaled_average() * c->_byte_rate.epoch_frequency(), c->_byte_rate.scale() - 3);
	else
	    return cp_unparse_real2(c->_byte_rate.scaled_average() * c->_byte_rate.epoch_frequency() * 8, c->_byte_rate.scale());
      case H_BYTE_RATE:
	c->_byte_rate.update(0); // drop rate after idle period
	return c->_byte_rate.unparse_rate();
      case H_COUNT_CALL:
	if (c->_count_trigger_h)
	    return String(c->_count_trigger);
	else
	    return String();
      default:
	return "<error>";
    }
}

int
MalwareDetect::write_handler(const String &in_str, Element *e, void *thunk, ErrorHandler *errh)
{
    MalwareDetect *c = (MalwareDetect *)e;
    String str = in_str;
    switch ((intptr_t)thunk) {
      case H_COUNT_CALL:
	  if (!IntArg().parse(cp_shift_spacevec(str), c->_count_trigger))
	    return errh->error("'count_call' first word should be unsigned (count)");
	if (HandlerCall::reset_write(c->_count_trigger_h, str, c, errh) < 0)
	    return -1;
	c->_count_triggered = false;
	return 0;
      case H_BYTE_COUNT_CALL:
	  if (!IntArg().parse(cp_shift_spacevec(str), c->_byte_trigger))
	    return errh->error("'byte_count_call' first word should be unsigned (count)");
	if (HandlerCall::reset_write(c->_byte_trigger_h, str, c, errh) < 0)
	    return -1;
	c->_byte_triggered = false;
	return 0;
      case H_RESET:
	c->reset();
	return 0;
      default:
	return errh->error("<internal>");
    }
}

void
MalwareDetect::add_handlers()
{
    add_read_handler("count", read_handler, H_COUNT);
    add_read_handler("byte_count", read_handler, H_BYTE_COUNT);
    add_read_handler("rate", read_handler, H_RATE);
    add_read_handler("bit_rate", read_handler, H_BIT_RATE);
    add_read_handler("byte_rate", read_handler, H_BYTE_RATE);
    add_write_handler("reset", write_handler, H_RESET, Handler::BUTTON);
    add_write_handler("reset_counts", write_handler, H_RESET, Handler::BUTTON | Handler::UNCOMMON);
    add_read_handler("count_call", read_handler, H_COUNT_CALL);
    add_write_handler("count_call", write_handler, H_COUNT_CALL);
    add_write_handler("byte_count_call", write_handler, H_BYTE_COUNT_CALL);
}

int
MalwareDetect::llrpc(unsigned command, void *data)
{
  if (command == CLICK_LLRPC_GET_RATE) {
    uint32_t *val = reinterpret_cast<uint32_t *>(data);
    if (*val != 0)
      return -EINVAL;
    _rate.update(0);		// drop rate after idle period
    *val = _rate.rate();
    return 0;

  } else if (command == CLICK_LLRPC_GET_COUNT) {
    uint32_t *val = reinterpret_cast<uint32_t *>(data);
    if (*val != 0 && *val != 1)
      return -EINVAL;
    *val = (*val == 0 ? _count : _byte_count);
    return 0;

  } else if (command == CLICK_LLRPC_GET_COUNTS) {
    click_llrpc_counts_st *user_cs = (click_llrpc_counts_st *)data;
    click_llrpc_counts_st cs;
    if (CLICK_LLRPC_GET_DATA(&cs, data, sizeof(cs.n) + sizeof(cs.keys)) < 0
	|| cs.n >= CLICK_LLRPC_COUNTS_SIZE)
      return -EINVAL;
    for (unsigned i = 0; i < cs.n; i++) {
      if (cs.keys[i] == 0)
	cs.values[i] = _count;
      else if (cs.keys[i] == 1)
	cs.values[i] = _byte_count;
      else
	return -EINVAL;
    }
    return CLICK_LLRPC_PUT_DATA(&user_cs->values, &cs.values, sizeof(cs.values));

  } else
    return Element::llrpc(command, data);
}

CLICK_ENDDECLS
EXPORT_ELEMENT(MalwareDetect)

